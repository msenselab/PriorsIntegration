---
title: "ModelReport"
author: "Fiona Zhu"
date: "05/03/2020"
header-includes:
   - \usepackage{amsmath}
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Load the packages
```{r include=FALSE}
source('runModel.r') #Parallel compute parameters for each subject each model
```


customize theme
```{r}
theme_new <- theme_bw() + 
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"),
        strip.background = element_rect(color = "white", fill = "white"),
        panel.grid = element_blank())

```


```{r}
options(mc.cores = parallel::detectCores()-1)
rstan_options (auto_write=TRUE)
```

## Define the Rstan models and functions to plot

### Definition of the function to merge rstan result data
To further uncover the underlying structure of the prior, we hypothesize that in addition to two local priors, there is a general global prior.Participants may combine both local and global priors for the final reproduction. There are multiple possibilities for integrating those local and global priors with the sensory inputs. For examples, the sensory input could first integrate with the local prior, and then integrate with the global prior (a hierarchical local-global model, see Figure 7B in D1 proposal). 

Our Hypothesis

* H2:  A hierarchical local-global model
In H2, global and local priors are integrated first. That means local prior is integrated with sensory input firstly, then global prior integrates with sensory input. 

The sensory input ($D_s$) first integrates with the local prior ($P_L$) to a posterior ($D_L$), which further integrates with the global prior ($P_G$) to generate a final posterior for reproduction ($D_r$).


* H3: Global prior (the dual integration model)

integration of local priors firstly, then integration of the global prior

Both local and global priors independently integrate with the sensory inputs to generate two posteriors ($D_L$) and ($D_G$), the latter two are combined together for reproduction ($D_r$).


#### Merg different version of model results

```{r}
# this R script is designed for the analysis of the result of Rstan model.
mergeData <- function(cvsfiles, filename, versionlist){
  merge.data.all = {}
  for(version in versionlist){
    merge.data = {}
    dataDir <- paste0(rstanmodelPath, "/", version )
    merge.data <- read.csv(file.path(dataDir, cvsfiles[1]),  header=T)
    merge.data$model = modellist[1]
    if (length(cvsfiles) >= 2) {
      for (i in 2:length(cvsfiles)){
        new.data = read.csv(file.path(dataDir, cvsfiles[i]),  header=T)
        new.data$model = modellist[i]
        merge.data = rbind(merge.data,new.data)
      }
    }
    merge.data$version=version
    merge.data.all = rbind(merge.data.all, merge.data)
    
  }
  savedataDir <- file.path(paste0(dataDir, "/AllDat_", filename, ".csv"))
  write.csv(file=savedataDir, merge.data.all)
}
```




### H3_old: Global prior (the dual integration model)
```{r}
stancodeH3_old <- '//H3: Prior is dynamic updated (Global prior)
//integration of local priors firstly, then integration of the global prior
data {  
  real a_s;  // short outlier group intercept 
  real b_s;  // short outlier group slope 
  real a_l;  // long outlier group intercept 
  real b_l;  // long outlier group slope 
  real<lower=0, upper =1> p_wf;  //Webber Fraction of the local prior
  int<lower=0> n_mix; //number of the up mixed data points
  real<lower=0> X_mix[n_mix]; //measured reproductive duration (mixed) 
  real<lower=0> Y_mix[n_mix]; //measured reproductive duration (mixed) 
  int<lower=0> n_mix_te; //number of the up mixed data points (test the model)
  real<lower=0> X_mix_te[n_mix_te]; //measured reproductive duration (mixed)
  real xmean[3];// mean of the target duration in each group
}

parameters { 
  real<lower=0, upper =1> wf;  //Webber Fraction of stimuli
  real<lower=0, upper =1> g_wf;  //Webber Fraction of the global prior
  vector<lower=0, upper =2.4>[n_mix] p_mix;
  vector<lower=0, upper =2.4>[n_mix] globalprior;
  real sig;
}


model {
  real w1[n_mix];

  for (m in 1:n_mix)  //integration of local priors firstly
  {
  if (X_mix[m] < 1){
    p_mix[m] ~ normal(a_s + b_s * X_mix[m], (a_s + b_s * X_mix[m])*p_wf) ;  // local prior  // or xmean[1]
  }else{
    p_mix[m] ~ normal(a_l + b_l * X_mix[m], (a_l + b_l * X_mix[m])*p_wf);  // local prior  // or xmean[2]
  }
  globalprior[m] ~ normal(xmean[3], xmean[3]*g_wf);
  w1[m] = (X_mix[m]^2 *wf^2 )/ ((X_mix[m]^2 *wf^2 ) + (xmean[3]^2 *g_wf^2 ));
  Y_mix[m] ~ normal(w1[m] * X_mix[m] + (1-w1[m])*xmean[3], sig); 
  }
}


generated quantities {
  vector[n_mix_te] globalprior_new;
  vector[n_mix_te] p_mix_new;
  vector[n_mix_te] w1_new;
  vector[n_mix_te] ynew_mix;

  for (m in 1:n_mix) //integration of local priors firstly
  {
    globalprior_new[m] = normal_rng(xmean[3], xmean[3]*g_wf) ;
    // H3 part1 integration of local priors firstly
    if (X_mix_te[m] < 1){
      p_mix_new[m] = normal_rng(a_s + b_s * X_mix_te[m], (a_s + b_s * X_mix_te[m])*p_wf) ;// local prior// or xmean[1]
    }else{
      p_mix_new[m] = normal_rng(a_l + b_l * X_mix_te[m], (a_l + b_l * X_mix_te[m])*p_wf);// local prior// or xmean[2]
    }
    
    w1_new[m] = (X_mix_te[m]*wf)^2 / ((X_mix_te[m]*wf)^2 +  (xmean[3]^2 *g_wf^2 )); //weight
    ynew_mix[m] = w1_new[m] * X_mix_te[m] + (1-w1_new[m])*globalprior_new[m];

  }
}
'

# compile models
stanmodeH3_old <- stan_model(model_code = stancodeH3_old, model_name="H3_old")

```

### predicte the parameters of Bayesian



###funFitBayesianStan

The definition of the function to predicte the parameters of Bayesian by runing Rstan model with full data

```{r}
funFitBayesianStan <- function(data, rstanModel, filename){
  Bayparlist = {}
  PredYlist_mix  = {}
  expList <- unique(data$Exp)
  subList <- unique(data$NSub)
  
  for (expName in expList) {
    xmean <- data %>% filter(valid > 0 & Exp == expName)  %>% dplyr::group_by(group, Exp) %>% dplyr::summarise(targetMean =mean(targetDur),RPMean =mean(RP))
    
    for (subNo in subList) {
      print(paste0('Start working on Subject No.',subNo, ' in ', expName))
      
      subdata <- data %>% filter(valid > 0 & Exp == expName)
      subList <- unique(data$NSub)
      baselinepar <- BaselinePar %>% filter(Nsub == subNo & Exp == expName)
      data_s<- subdata %>% filter(group == 1)  # short groups 
      data_l <- subdata %>% filter(group == 2)  # long groups 
      data_mix <- subdata %>% filter(group == 3)  # mixed groups 
      
      n_mix = length(data_mix$RP)
      n_mix_te = length(data_mix$RP)
      
      stan_data = list( a_s =  baselinepar$a_s,
                        b_s =  baselinepar$b_s,
                        a_l =  baselinepar$a_l,
                        b_l =  baselinepar$b_l,
                        p_wf = baselinepar$p_wf, 
                        Y_mix = data_mix$RP, 
                        n_mix = n_mix, 
                        X_mix = data_mix$targetDur, 
                        X_mix_te = data_mix$targetDur, 
                        n_mix_te = n_mix_te,
                        xmean = xmean$RPMean)  #data passed to stan
      
      PredY_mix_list <- data_mix[c('NSub','targetDur', 'RP','Exp','group')]
      
      # myinits <-list(list(g_wf=0.2,wf=0.2, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w_mix = rep(0.5, n_mix)),
      #  list(g_wf=0.2,wf=0.2, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w1 = rep(0.5, n_mix)),
      #  list(g_wf=0.2,wf=0.2, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w1 = rep(0.5, n_mix)),
      #  list(g_wf=0.2,wf=0.2, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w1 = rep(0.5, n_mix)))
      
      
      
      #myinits <-list(list(wf =0.3, g_wf=0.3, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w1 = rep(0.5, n_mix)),
      #         list(wf =0.3, g_wf=0.3, globalprior=rep(xmean$RPMean[3], n_mix), p_mix = rep(xmean$RPMean[3], n_mix), w1 = rep(0.5, n_mix)))
      
      # fit models
      parameters <- c("g_wf", "wf_m", "ynew_mix", "sig_mix_square", "w1_new", "w2_new")  #"globalprior", "globalprior_new"
      subfit <- sampling(rstanModel, 
                         stan_data,
                         #   init=myinits,
                         iter=4000,
                         chains=4,
                         thin=1,
                         control = list(adapt_delta = 0.99,
                                        max_treedepth = 15))
      ## Launch shinystan and save the resulting shinystan object
      #sf_sso <- launch_shinystan(subfit)
      #rdspath <- paste0("reproduction_outlier/data/sso_", subNo,"_",expName)
      #save_rds(subfit, rdspath)
      
      # print(subfit)
      # plot(subfit)
      # stan_trace(subfit)
      # stan_trace(subfit, inc_warmup = TRUE)
      # pairs(subfit)
      
      fitpar <- summary(subfit, pars = parameters)$summary
      list_of_draws <- rstan::extract(subfit, pars = parameters)
      wf_m =  mean(list_of_draws$wf_m)
      g_wf =  mean(list_of_draws$g_wf)
      
      pred_y_mix <- {}
      w1_list_mix <- {}
      w2_list_mix <- {}
      ynew_mix_list <- list_of_draws$ynew_mix
      w1_list <- list_of_draws$w1_new
      w2_list <- list_of_draws$w2_new
      for (n in 1:n_mix){
        pred_y_mix[n] <-  mean(ynew_mix_list[,n] )
        w1_list_mix[n] <-  mean(w1_list[,n] )
        w2_list_mix[n] <-  mean(w2_list[,n] )
      }
      PredY_mix_list$predY = pred_y_mix
      PredY_mix_list$w1 = w1_list_mix
      PredY_mix_list$w2 = w2_list_mix
      PredYlist_mix <- rbind2(PredYlist_mix, PredY_mix_list)
      
      Baypar = data.frame(
        Nsub = subNo,
        Exp = expName,
        a_s =  baselinepar$a_s,
        b_s =  baselinepar$b_s,
        a_l =  baselinepar$a_l,
        b_l =  baselinepar$b_l,
        p_wf = baselinepar$p_wf,
        wf_m = wf_m,
        g_wf = g_wf
      )
      Bayparlist <- rbind2(Bayparlist, Baypar)
    }
  }
  write.csv(Bayparlist, file = paste0(modelResultPath, "/Bayparlist_", filename,".csv"))
  write.csv(PredYlist_mix, file = paste0(modelResultPath, "/PredY_mix_", filename,".csv"))
  
  return(list("Bayparlist" = Bayparlist, "PredYlist_mix" = PredYlist_mix))
}
```


### funFitStanSub



## run the model

### run H2

```{r include=FALSE}
## H2: Prior is dynamic updated (the distribution of the prior is updated. In H2, global and local priors are integrated first)

if (runModels == TRUE){
  #BayparlistH2  <- funFitBayesianStan(AllExpData, stanmodeH2,'H2')
  expList <- unique(AllExpData$Exp)
  subList <- unique(AllExpData$NSub)
  modellist <- c('H2_V1', 'H3_V1', 'H2_V2_2')

  sub_exp_dat <- list()
  for(modelname in modellist) {
    for (expName in expList) {
        data_exp <- AllExpData %>% dplyr::filter(valid  == 1 & Exp == expName)
        data_exp$model <- modelname
        sub_exp <-  split(data_exp, data_exp$NSub) # split data for each subject
        for (subNo in subList) {
          sub_exp_dat <- list.append(sub_exp_dat, sub_exp[[subNo]])
        }
    }
  }
   runModelcluster(sub_exp_dat)
}
```




### run H3
```{r include=FALSE}
##H3: 
if (runModels == TRUE){
  BayparlistH3  <- funFitBayesianStan(AllExpData, stanmodeH3,'H3')
}

```


## display the model restults

### Merge the Result data 

To preprocess the model result data, and merge different model version data together.

```{r}
needpreprocess=1
versionlist =c('Version1')
modellist = c('H2')

if (needpreprocess == 1){
  
  predY_mix_filename <- paste0("PredY_mix_", modellist, ".csv")
  BayParlist_filename <- paste0("Bayparlist_", modellist, ".csv")
  mergeData(predY_mix_filename, 'predY_mix', versionlist)
  mergeData(BayParlist_filename, 'Bayparlist', versionlist)
}

```

### load the model result data

```{r}
AllDat_Bayparlist <- read_csv(paste0(rstanmodelPath, "/AllDat_Bayparlist.csv"))
AllDat_predY_mix <- read_csv(paste0(rstanmodelPath, "/AllDat_predY_mix.csv"))
```



### Analysis on the Rstan model parameters

#### Parameters
```{r}
# AllDat_Bayparlist$model <- factor(AllDat_Bayparlist$model, labels = c( "Hierarchical local-global model","Dual integration model"))
m_Baypar <- dplyr::group_by(AllDat_Bayparlist, Exp, model, version) %>%
  dplyr::summarize(m_as = mean(a_s), m_al = mean(a_l),
                   m_bs = mean(b_s), m_bl = mean(b_l),
                   m_wf = mean(wf), m_pwf = mean(p_wf) ) 
m_Baypar
```


###  wf in models
```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_as, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```

```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_bs, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```

```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_al, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```

```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_bl, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```


```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_wf, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```

```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_pwf, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) 
```


## Prediction results (mixed block)

```{r}
AllDat_predY_mix$model <- factor(AllDat_predY_mix$model, labels = c( "Hierarchical local-global model","Dual integration model"))

predY_mix <- group_by(AllDat_predY_mix, targetDur, Exp, NSub, model,version) %>%
  summarize(m_RP = mean(RP), n = n(), sd_RP = sd(RP)/ sqrt(n-1),m_predY = mean(predY), sd_predY = sd(predY)/ sqrt(n-1)) %>%
  group_by(targetDur, Exp, model,version) %>%
  summarize(
    n = n(),
    m_m_predY = mean(m_predY),
    se_m_predY = sd(m_predY) / sqrt(n - 1),
    m_m_RP = mean(m_RP),
    se_m_RP = sd(m_RP) / sqrt(n-1)
  )
predY_mix
```



```{r}
predY_mix$m_rpErr = predY_mix$m_m_predY - predY_mix$m_m_RP
predY_mix$m_relativeErr = predY_mix$m_rpErr / predY_mix$targetDur
```

### The predication of mixed block

```{r}
#plot Error in mixed blocks
ggplot(data=predY_mix, aes(x= targetDur, y=m_rpErr, group = model, color= model)) + 
  geom_bar(stat="identity")+
  labs(x="target intervals", y="Error (predicted RP minus measured reproduction)")+
  facet_wrap(Exp~model) 
```


```{r}
#plot relative Error for mixed blocks
fig_rerr_model <-  ggplot(data=predY_mix, aes(x= targetDur, y=m_relativeErr*100, group = model, color= model)) + 
  geom_bar(stat="identity")+
  labs(x="target intervals", y="relative error (%)")+
  facet_wrap(Exp~model) 

ggsave(file.path('figures','fig_rerr_model.png'), fig_rerr_model, width = 7, height = 5)
```


```{r}
#plot the average of the predicted Y under the mixed condition
fig_mPredY_mix = ggplot(predY_mix) + 
  geom_point(aes(targetDur, m_m_predY, group = model, color = model)) + 
  geom_line(aes(targetDur, m_m_RP, group = model, color = model),  size = 1) + 
  #geom_errorbar(aes(ymin = m_m_predY-se_m_predY, ymax = m_m_predY + se_m_predY), width = 0.05) + 
  geom_abline(slope = 1, linetype = 2, size = 1) + # add diagonal line
  facet_wrap(~Exp) +
  guides(color = guide_legend(title = element_blank())) + # remove legend title
  theme_classic() + 
  theme(strip.background = element_blank()) + # remove subtitle background
  labs(x = "Durations (secs)", y = "Mean Reproductions (secs)", size =15) + theme(legend.position="bottom")+
  theme_new

fig_mPredY_mix


ggsave(file.path('figures','fig_mPredY_mix.png'), fig_mPredY_mix, width = 7, height = 5)
```

```{r}
predY_mix$rpErr_squared <- predY_mix$m_rpErr^2
m_predY_Err <- dplyr::group_by(predY_mix, Exp, model,version) %>%
  dplyr::summarize(sum_rpErr = sum(rpErr_squared), 
                   n = n())

fig_rpErr_model <- ggplot(m_predY_Err, aes(x = Exp, y = sum_rpErr, color = model, fill = model, group = model)) + 
  geom_bar(stat = "identity",
           position = position_dodge()) + theme(legend.position="bottom")+
  theme_new

ggsave(file.path('figures','fig_rpErr_model.png'), fig_rpErr_model, width = 7, height = 5)

fig_rpErr_model
```






