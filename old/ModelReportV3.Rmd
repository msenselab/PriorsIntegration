---
title: "ModelReport"
author: "Fiona Zhu"
date: "05/03/2020"
header-includes:
   - \usepackage{amsmath}
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Load the packages
```{r}
library(tidyverse)
library(rstan)
library(readr)
```


```{r}
options(mc.cores = parallel::detectCores())
rstan_options (auto_write=TRUE)
# flag for saving figures 
saveFigure = TRUE
# flag for generating CSV  
generateSCV = TRUE
# flag for running rstan model and saving the results
runModels = FALSE
# path of model result
rstanmodelPath = 'RSTANMODELS'
modelResultPath = paste0(rstanmodelPath, '/Version3')
```

## load experimental data

```{r include=FALSE}
## generate the Baseline parameters
AllExpData <- read_csv(paste0("data/AllExpData.csv"))
```


## RStan Models

### Definition of the function to merge rstan result data
To further uncover the underlying structure of the prior, we hypothesize that in addition to two local priors, there is a general global prior.Participants may combine both local and global priors for the final reproduction. There are multiple possibilities for integrating those local and global priors with the sensory inputs. For examples, the sensory input could first integrate with the local prior, and then integrate with the global prior (a hierarchical local-global model, see Figure 7B in D1 proposal). 

Our Hypothesis

* H1:  Short and long is independent

* H3:  A hierarchical local-global model
In H3, global and local priors are integrated first. That means local prior is integrated with sensory input firstly, then global prior integrates with sensory input. 

The sensory input ($D_s$) first integrates with the local prior ($P_L$) to a posterior ($D_L$), which further integrates with the global prior ($P_G$) to generate a final posterior for reproduction ($D_r$).


* H4: Global prior (the dual integration model)

integration of local priors firstly, then integration of the global prior

Both local and global priors independently integrate with the sensory inputs to generate two posteriors ($D_L$) and ($D_G$), the latter two are combined together for reproduction ($D_r$).


#### Merg different version of model results

```{r}
# this R script is designed for the analysis of the result of Rstan model.
mergeData <- function(cvsfiles, filename, versionlist){
  merge.data.all = {}
  for(version in versionlist){
    merge.data = {}
    dataDir <- paste0(rstanmodelPath, "/", version,"/data" )
    merge.data <- read.csv(file.path(dataDir, cvsfiles[1]),  header=T)
    merge.data$model = modellist[1]
    if (length(cvsfiles) >= 2) {
      for (i in 2:length(cvsfiles)){
        new.data = read.csv(file.path(dataDir, cvsfiles[i]),  header=T)
        new.data$model = modellist[i]
        merge.data = rbind(merge.data,new.data)
      }
    }
    merge.data$version=version
    merge.data.all = rbind(merge.data.all, merge.data)
    
  }
  savedataDir <- file.path(paste0(rstanmodelPath, "/AllDat_", filename, ".csv"))
  write.csv(file=savedataDir, merge.data.all)
}
```



### H3:  A hierarchical local-global model
```{r}
stancodeH3 <- '//H3: Prior is dynamic updated (the distribution of the prior is updated)
//In H3, global and local priors are integrated first. That means local prior is integrated with sensory input firstly, 
// then global prior integrates with sensory input. 
data {  
int<lower=0> n_s;  //number of the short group baseline data points
int<lower=0> n_l;  //number of the long group baseline data points
real<lower=0> Y_s[n_s];   //measured reproductive duration (short group)
real<lower=0> X_s[n_s];   //stimulus duration (short group)
real<lower=0> Y_l[n_l];   //measured reproductive duration (long group)
real<lower=0> X_l[n_l];   //stimulus duration (long group)

int<lower=0> n_mix; //number of the up mixed data points
real<lower=0> X_mix[n_mix]; //measured reproductive duration (mixed) 
real<lower=0> Y_mix[n_mix]; //measured reproductive duration (mixed) 
int<lower=0> n_mix_te; //number of the up mixed data points (test the model)
real<lower=0> X_mix_te[n_mix_te]; //measured reproductive duration (mixed)
}

parameters { 
real<lower=0, upper = 1> p_wf;  //Weber Fraction of prior
real<lower=0, upper = 1> wf;  //Weber Fraction of prior
real<lower=0, upper = 1> sigma;   //sd 
real<lower=0, upper = 1> g_wf;  //Webber Fraction for the global prior
real a_s;
real b_s;
real a_l;
real b_l;
}

transformed parameters { 
real g_mean = mean(X_mix);
real sig_mix = g_mean*g_wf;  //global prior of up mixed block 
}

model {
real p_mix[n_mix];
real p_sig_mix[n_mix];
real w_mix[n_mix];
real d_mix_hat[n_mix];
real var_mix[n_mix];
real g_w_mix[n_mix];
real y_mix_mean[n_mix];

//hyperpriors
a_s ~ normal(0, 1);   // short group intercept
b_s ~ normal(1, 1);   // short group slope
a_l ~ normal(0, 1);   // long group intercept
b_l ~ normal(1, 1);   // long group slope

for (i in 1:n_s)
{
  Y_s[i] ~ normal(a_s + b_s * X_s[i], sigma*X_s[i]); //short groups
}

for (j in 1:n_l)
{
  Y_l[j] ~ normal(a_l + b_l * X_l[j], sigma*X_l[j]); //long groups
}

for (m in 1:n_mix)  
{
  // integration of local priors firstly
  if (X_mix[m] < 1){
    p_mix[m] = a_s+ b_s * X_mix[m];
  }else{
    p_mix[m] = a_l+ b_l * X_mix[m];
  }
  p_sig_mix[m] = p_mix[m] * p_wf;
  w_mix[m] = p_sig_mix[m]^2 / (p_sig_mix[m]^2 +  (X_mix[m]*wf)^2);
  d_mix_hat[m] = w_mix[m] * X_mix[m] + (1-w_mix[m])*p_mix[m];

  // posterior variances
  var_mix[m] = p_sig_mix[m]^2 * (X_mix[m]*wf)^2 / (p_sig_mix[m]^2 + (X_mix[m]*wf)^2);
  // integration of the global prior
  g_w_mix[m] = sig_mix^2 / (sig_mix^2 + var_mix[m]);
  y_mix_mean[m] = g_w_mix[m] * d_mix_hat[m]  + (1-g_w_mix[m]) * g_mean;
  Y_mix[m] ~ normal(y_mix_mean[m], sigma* X_mix[m]); 
}

}

generated quantities {
vector[n_mix_te] ynew_mix;
vector[n_mix_te] p_mix_new;
vector[n_mix_te] p_sig_mix_new;
vector[n_mix_te] w_mix_new;
vector[n_mix_te] d_mix_hat_new;
vector[n_mix_te] var_mix_new;
vector[n_mix_te] g_w_mix_new;

for (m in 1:n_mix_te)  //prediction of up mixed range
{
  // integration of local priors firstly
  if (X_mix_te[m] < 1){
    p_mix_new[m] = a_s+ b_s * X_mix_te[m];
  }else{
    p_mix_new[m] = a_l+ b_l * X_mix_te[m];
  }
  p_sig_mix_new[m] = p_mix_new[m] * p_wf;
  w_mix_new[m] = p_sig_mix_new[m]^2 / (p_sig_mix_new[m]^2 +  (X_mix_te[m]*wf)^2);
  d_mix_hat_new[m] = w_mix_new[m] * X_mix_te[m] + (1-w_mix_new[m])*p_mix_new[m];

  // posterior variances
  var_mix_new[m] = p_sig_mix_new[m]^2 * (X_mix_te[m]*wf)^2 / (p_sig_mix_new[m]^2 + (X_mix_te[m]*wf)^2);
  // integration of the global prior
  g_w_mix_new[m] = sig_mix^2 / (sig_mix^2 + var_mix_new[m]);
  ynew_mix[m] = g_w_mix_new[m] * d_mix_hat_new[m]  + (1-g_w_mix_new[m]) * g_mean;
}

}
'
```

### H4: the dual integration model
```{r}
stancodeH4 <- '//H4: The dual integration model
//integration of local priors firstly, then integration of the global prior
data {  
int<lower=0> n_s;  //number of the short group baseline data points
int<lower=0> n_l;  //number of the long group baseline data points
real<lower=0> Y_s[n_s];   //measured reproductive duration (short group)
real<lower=0> X_s[n_s];   //stimulus duration (short group)
real<lower=0> Y_l[n_l];   //measured reproductive duration (long group)
real<lower=0> X_l[n_l];   //stimulus duration (long group)

int<lower=0> n_mix; //number of the mixed data points
real<lower=0> X_mix[n_mix]; //measured target duration (mixed group) 
real<lower=0> Y_mix[n_mix]; //measured reproductive duration (mixed group) 
int<lower=0> n_mix_te; //number of the mixed data points (test the model)
real<lower=0> X_mix_te[n_mix_te]; //measured reproductive duration (up mixed)
}

parameters { 
real<lower=0, upper = 1> p_wf;  //Weber Fraction of prior
real<lower=0, upper = 1> wf;  //Weber Fraction of prior
real<lower=0, upper = 1> sigma;   //sigma 
real<lower=0, upper = 1> g_wf;  //Webber Fraction for the global prior
real a_s;
real b_s;
real a_l;
real b_l;
}

transformed parameters { 
real g_mean = mean(X_mix);
//real sig_mix = g_mean*g_wf;  //global prior of up mixed block  
}


model {
real w_mix[n_mix];
real p_sig_mix[n_mix];
real p_mix[n_mix];
real pp_mix[n_mix];
real pp_mix_var[n_mix];
real pp_w[n_mix];
real sig_mix[n_mix];


//hyperpriors
a_s ~ normal(0, 1);   // short group intercept
b_s ~ normal(1, 1);   // short group slope
a_l ~ normal(0, 1);   // long group intercept
b_l ~ normal(1, 1);   // long group slope
//priors


//likelihood
for (i in 1:n_s)
{
  Y_s[i] ~ normal(a_s + b_s * X_s[i], sigma*X_s[i]); //short groups
}

for (j in 1:n_l)
{
  Y_l[j] ~ normal(a_l + b_l * X_l[j], sigma* X_l[j]); //long groups
}


for (m in 1:n_mix)  //integration of local priors firstly
{// first integration 
  if(X_mix[m] < 1){
    p_mix[m] = a_s+ b_s* X_mix[m];
  }
  else{
    p_mix[m] = a_l+ b_l * X_mix[m];
  }
  sig_mix[m] = mean(X_mix[1:m])*g_wf;  //global prior of up mixed block  
  p_sig_mix[m] = p_mix[m] * p_wf;
  w_mix[m] = sig_mix[m]^2 / (sig_mix[m]^2 + p_sig_mix[m]^2);
  pp_mix[m] = p_mix[m] * w_mix[m] + (1- w_mix[m]) * g_mean;
  pp_mix_var[m] = sig_mix[m]^2* p_sig_mix[m]^2/(sig_mix[m]^2 + p_sig_mix[m]^2);
  pp_w[m] = pp_mix_var[m]  / (pp_mix_var[m]  + X_mix[m]^2 * wf^2);
  Y_mix[m] ~ normal(pp_w[m] * X_mix[m] + (1-pp_w[m])*pp_mix[m], sigma* X_mix[m]); 
}
}


generated quantities {
vector[n_mix_te] ynew_mix;
vector[n_mix_te] w_mix_new;
vector[n_mix_te] p_sig_mix_new;
vector[n_mix_te] pp_mix_new;
vector[n_mix_te] pp_mix_var_new;
vector[n_mix_te] pp_w_new;
vector[n_mix_te] p_mix_new;
vector[n_mix_te] sig_mix_new;


for (m in 1:n_mix_te)  //prediction of up mixed range
{
  // first integration 
  if(X_mix_te[m] < 1){
    p_mix_new[m] = a_s+ b_s* X_mix[m];
  }
  else{
    p_mix_new[m] = a_l+ b_l * X_mix[m];
  }
  sig_mix_new[m] = mean(X_mix_te[1:m])*g_wf;  //global prior of up mixed block  
  p_sig_mix_new[m] = p_mix_new[m] * p_wf;
  w_mix_new[m] = sig_mix_new[m]^2 / (sig_mix_new[m]^2 + p_sig_mix_new[m]^2);
  pp_mix_new[m] = p_mix_new[m] * w_mix_new[m] + (1- w_mix_new[m]) * mean(X_mix_te);
  
  pp_mix_var_new[m] = sig_mix_new[m]^2* p_sig_mix_new[m]^2/(sig_mix_new[m]^2 + p_sig_mix_new[m]^2);
  pp_w_new[m] = pp_mix_var_new[m]  / (pp_mix_var_new[m]  + X_mix_te[m]^2* wf^2);
  ynew_mix[m] = pp_w_new[m] * X_mix_te[m] + (1-pp_w_new[m])*pp_mix_new[m]; 

}

}
'
```





#### predicte the parameters of Bayesian

definisiton of the function to predicte the parameters of Bayesian by runing Rstan model

  
```{r}
funFitBayesianStan <- function(data, rstanModel, filename){
  Bayfit = {}
  Bayparlist = {}
  PredYlist_mix  = {}
  sf_ssolist = {}
  subList <- unique(data$NSub)
  expList <- unique(data$Exp)
  
  for (expName in expList) {
    for (subNo in subList) {
      print(paste0('Start working on Subject No.',subNo, ' in ', expName))
      
      pred_y_mix = {}
      subdata <- data %>% filter(valid > 0 & Exp == expName)
      subList <- unique(data$NSub)
      data_s<- subdata %>% filter(group == 1)  # short groups 
      data_l <- subdata %>% filter(group == 2)  # long groups 
      data_mix <- subdata %>% filter(group == 3)  # mixed groups 
      
      n_mix = length(data_mix$RP)
      n_mix_te = length(data_mix$RP)
      
      stan_data = list(Y_s=data_s$RP, 
                       n_s=length(data_s$RP), 
                       X_s = data_s$targetDur,
                       Y_l=data_l$RP, 
                       n_l=length(data_l$RP), 
                       X_l = data_l$targetDur,
                       Y_mix = data_mix$RP, 
                       n_mix = n_mix, 
                       X_mix = data_mix$targetDur, 
                       X_mix_te = data_mix$targetDur, 
                       n_mix_te = n_mix_te)  #data passed to stan
      
      testdat_mix <- data_mix[c('NSub','targetDur', 'RP','Exp','group')]
      
      # fit models
      subfit <- sampling(rstanModel, stan_data)
      ## Launch shinystan and save the resulting shinystan object
      #sf_sso <- launch_shinystan(subfit)
      #rdspath <- paste0("reproduction_outlier/data/sso_", subNo,"_",expName)
      #save_rds(subfit, rdspath)
      
      # print(subfit)
      # plot(subfit)
      # stan_trace(subfit)
      # stan_trace(subfit, inc_warmup = TRUE)
      # pairs(subfit)
      
      
      parameters <- c("a_s","b_s", "a_l","b_l", "sigma","wf","p_wf","g_wf","ynew_mix")  
      fitpar <- summary(subfit, pars = parameters)$summary
      
      
      list_of_draws <- rstan::extract(subfit, pars = parameters)
      a_s =  mean(list_of_draws$a_s)
      b_s = mean(list_of_draws$b_s) 
      a_l = mean(list_of_draws$a_l) 
      b_l = mean(list_of_draws$b_l) 
      sigma = mean(list_of_draws$sigma)
      wf =  mean(list_of_draws$wf)
      p_wf =  mean(list_of_draws$p_wf)
      g_wf =  mean(list_of_draws$g_wf)
      for (n in 1:n_mix_te){
        pred_y_mix[n] <-  mean(list_of_draws$ynew_mix[,n] )
      }
      testdat_mix$predY = pred_y_mix
      PredYlist_mix <- rbind2(PredYlist_mix, testdat_mix)
      
      
      Baypar = data.frame(
        Nsub = subNo,
        Exp = expName,
        a_s =  a_s,
        b_s =  b_s,
        a_l = a_l,
        b_l =  b_l,
        sigma = sigma,
        wf = wf,
        p_wf = p_wf,
        g_wf = g_wf
      )
      Bayparlist <- rbind2(Bayparlist, Baypar)
    }
  }
  write.csv(Bayparlist, file = paste0(modelResultPath, "/data/Bayparlist_Stan_", filename,".csv"))
  write.csv(PredYlist_mix, file = paste0(modelResultPath, "/data/PredY_mix_Stan_", filename,".csv"))

  return(list("Bayparlist" = Bayparlist, "PredYlist_mix" = PredYlist_mix))
}


```


## run the model

### run H3

```{r}
# compile models
stanmodeH3 <- stan_model(model_code = stancodeH3, model_name="stanmodelH3")
```

```{r include=FALSE}
## H3: Prior is dynamic updated (the distribution of the prior is updated. In H3, global and local priors are integrated first)
BayparlistH3  <- funFitBayesianStan(AllExpData, stanmodeH3,'H3')
```

### run H4

```{r include=FALSE}
# compile models
stanmodeH4 <- stan_model(model_code = stancodeH4, model_name="stanmodelH4")
```

```{r include=FALSE}
##H4: integration of local priors( In H4, firstly integration of local priors, then integration of the global prior)
BayparlistH4  <- funFitBayesianStan(AllExpData, stanmodeH4,'H4')
```


## display the model restults

### Merge the Result data 

To preprocess the model result data, and merge different model version data together.

```{r}
needpreprocess=1
versionlist =c('Version3')
modellist = c('H3', 'H4')

if (needpreprocess == 1){
  predY_mix_filename <- paste0("PredY_mix_Stan_", modellist, ".csv")
  BayParlist_filename <- paste0("Bayparlist_Stan_", modellist, ".csv")
  mergeData(predY_mix_filename, 'predY_mix', versionlist)
  mergeData(BayParlist_filename, 'Bayparlist', versionlist)
}

```

### load the model result data

```{r}
AllDat_Bayparlist <- read_csv(paste0(rstanmodelPath, "/AllDat_Bayparlist.csv"))
AllDat_predY_mix <- read_csv(paste0(rstanmodelPath, "/AllDat_predY_mix.csv"))
```



### Analysis on the Rstan model parameters

#### Parameters
```{r}
  AllDat_Bayparlist$model <- factor(AllDat_Bayparlist$model, labels = c( "Hierarchical local-global model","Dual integration model"))
m_Baypar <- group_by(AllDat_Bayparlist, Exp, Nsub, model,version) %>%
  summarize(m_as = mean(a_s), n = n(), m_al = mean(a_l),
            m_bs = mean(b_s), m_bl = mean(b_l),
            m_wf = mean(wf), m_sigma=mean(sigma), 
            m_pwf =mean(p_wf), m_gwf =mean(g_wf)) %>%
group_by(Exp, model,version) %>%
  summarize(m_as = mean(m_as), n = n(), m_al = mean(m_al),
            m_bs = mean(m_bs), m_bl = mean(m_bl),
            m_wf = mean(m_wf),  m_sigma=mean(m_sigma), 
            m_pwf =mean(m_pwf), m_gwf =mean(m_gwf)) 
```


###  wf in models

```{r}
ggplot(m_Baypar, aes(x = Exp, y = m_al, color = model, fill = model, group = model)) + 
    geom_bar(stat = "identity",
             position = position_dodge()) 
```

## Prediction results (mixed block)

```{r}
AllDat_predY_mix$model <- factor(AllDat_predY_mix$model, labels = c( "Hierarchical local-global model","Dual integration model"))

predY_mix <- group_by(AllDat_predY_mix, targetDur, Exp, NSub, model,version) %>%
  summarize(m_RP = mean(RP), n = n(), sd_RP = sd(RP)/ sqrt(n-1),m_predY = mean(predY), sd_predY = sd(predY)/ sqrt(n-1)) %>%
  group_by(targetDur, Exp, model,version) %>%
  summarize(
    n = n(),
    m_m_predY = mean(m_predY),
    se_m_predY = sd(m_predY) / sqrt(n - 1),
    m_m_RP = mean(m_RP),
    se_m_RP = sd(m_RP) / sqrt(n-1)
  )
predY_mix
```



```{r}
predY_mix$m_rpErr = predY_mix$m_m_predY - predY_mix$m_m_RP
predY_mix$m_relativeErr = predY_mix$m_rpErr / predY_mix$targetDur
```

### The predication of mixed block

```{r}
#plot Error in mixed blocks
  ggplot(data=predY_mix, aes(x= targetDur, y=m_rpErr, group = model, color= model)) + 
    geom_bar(stat="identity")+
    labs(x="target intervals", y="Error (predicted RP minus measured reproduction)")+
  facet_wrap(Exp~model) 
```


```{r}
#plot relative Error for mixed blocks
 fig_rerr_model <-  ggplot(data=predY_mix, aes(x= targetDur, y=m_relativeErr*100, group = model, color= model)) + 
    geom_bar(stat="identity")+
    labs(x="target intervals", y="relative error (%)")+
  facet_wrap(Exp~model) 

ggsave(file.path('figures','fig_rerr_model.png'), fig_rerr_model, width = 7, height = 5)
fig_rerr_model
```


```{r}
#plot the average of the predicted Y under the mixed condition
fig_mPredY_mix = ggplot(predY_mix) + 
  geom_point(aes(targetDur, m_m_predY, group = model, color = model)) + 
  geom_line(aes(targetDur, m_m_RP, group = model, color = model),  size = 1) + 
  #geom_errorbar(aes(ymin = m_m_predY-se_m_predY, ymax = m_m_predY + se_m_predY), width = 0.05) + 
  geom_abline(slope = 1, linetype = 2, size = 1) + # add diagonal line
  facet_wrap(~Exp) +
  guides(color = guide_legend(title = element_blank())) + # remove legend title
  theme_classic() + 
  theme(strip.background = element_blank()) + # remove subtitle background
  labs(x = "Durations (secs)", y = "Mean Reproductions (secs)", size =15) + theme(legend.position="bottom")
fig_mPredY_mix


ggsave(file.path('figures','fig_mPredY_mix.png'), fig_mPredY_mix, width = 7, height = 5)
```

```{r}
predY_mix$rpErr_squared <- predY_mix$m_rpErr^2
m_predY_Err <- group_by(predY_mix, Exp, model,version) %>%
  summarize(sum_rpErr = sum(rpErr_squared), 
            n = n())

fig_rpErr_model <- ggplot(m_predY_Err, aes(x = Exp, y = sum_rpErr, color = model, fill = model, group = model)) + 
    geom_bar(stat = "identity",
             position = position_dodge()) + theme(legend.position="bottom")

ggsave(file.path('figures','fig_rpErr_model.png'), fig_rpErr_model, width = 7, height = 5)

fig_rpErr_model
```






