//
// This Stan program defines a dual integration model(DIM) for IR condition in duration reproduction task, with a
// vector of values 'Y_mix' modeled as normally distributed
// with mean 'mu_r' and standard deviation 'sig_r'.
// The dual integration model(DIM) assumes that each range has its own prior 
// and integrates with the sensory input separately firstly, and then the outputs
// from these integrations could be combined into the posteriors.
// Both local and global priors independently integrate with the sensory inputs
// to generate two posteriors (DL) and (DG), the latter two are combined together
// for estimate(De)
//


//user defined function in stan model
functions {
  real mu_lognormal(real mu, real sigma){
    return(log(mu) - 0.5 *log(1+sigma/mu^2));
  }
  
  real variance_lognormal(real mu, real sigma){
    return(log(1+sigma/mu^2));
  }
  
  real mu_normal(real mu, real sigma){
    return(exp(mu+ sigma *0.5));
  }
  
  real variance_normal(real mu, real sigma){
    return((exp(sigma)-1)*exp(2*mu + sigma));
  }
  
  real get_weight(real sig_t, real sig_p){
    return(sig_t /(sig_t + sig_p));
  }
  
  real get_mu(real wp_p, real mu_p, real x){  
    return(wp_p *mu_p +(1-wp_p) * x);
  }
  
  real get_variance(real sig_t, real sig_p){
    return(sig_t*sig_p/(sig_t + sig_p));
  }
  
  matrix predictor_mix_rng(real[] x, real sig2_t, real sig_pr2_s_log, real sig_pr2_l_log, real sig2_p_g_log, real mu_p_s_log, real mu_p_l_log, real mu_p_g_log, real sig2_mn, real phi) {
    vector[num_elements(x)] predY;         //predication of RP generated by model
    vector[num_elements(x)] wp_local;
    vector[num_elements(x)] mu_dL;
    vector[num_elements(x)] sig_dL_sq;
    vector[num_elements(x)] wp;
    vector[num_elements(x)] mu_r;
    vector[num_elements(x)] sig_r;
    vector[num_elements(x)] mu_r_log;
    vector[num_elements(x)] sig_r_log;
    vector[num_elements(x)] wp_Dg_Pg;
    vector[num_elements(x)] mu_dG;
    vector[num_elements(x)] sig_dG;
    vector[num_elements(x)] log_lik;
    
    for (m in 1:num_elements(x)) {
      if (x[m] < 1){
        //H3:short prior and integrates with the sensory input
        wp_local[m] = get_weight(sig2_t, sig_pr2_s_log); //weight of local short prior
        mu_dL[m] = get_mu(wp_local[m],  mu_p_s_log, log(x[m]));
        sig_dL_sq[m] = get_variance(sig2_t, sig_pr2_s_log);
      }else{
        //H3:long prior and integrates with the sensory input
        wp_local[m] = get_weight(sig2_t, sig_pr2_l_log);  //weight of local long prior
        mu_dL[m] = get_mu(wp_local[m], mu_p_l_log, log(x[m]));
        sig_dL_sq[m] = get_variance(sig2_t, sig_pr2_l_log);
      }
      
      //meanwile global prior and integrates with the sensory input
      wp_Dg_Pg[m] = get_weight(sig2_t, sig2_p_g_log);  //weight of global prior(PG) in DG
      mu_dG[m] = get_mu(wp_Dg_Pg[m], mu_p_g_log, log(x[m]));
      sig_dG[m] = get_variance(sig2_t, sig2_p_g_log);
      
      //integration DG and DL
      wp[m] = (sig_dL_sq[m] - phi*sqrt(sig_dG[m] *sig_dL_sq[m])) /(sig_dG[m]+sig_dL_sq[m]- 2*phi*sqrt(sig_dG[m]*sig_dL_sq[m])); //weight of D_G
      mu_r_log[m] =get_mu(wp[m], mu_dG[m], mu_dL[m]);
      sig_r_log[m] = (1-phi^2)*sig_dG[m]*sig_dL_sq[m] / (sig_dL_sq[m]+sig_dG[m]-2*phi*sqrt(sig_dG[m]*sig_dL_sq[m]));
      
      mu_r[m] = mu_normal(mu_r_log[m], sig_r_log[m]);
      sig_r[m] =sqrt(variance_normal(mu_r_log[m], sig_r_log[m]) +sig2_mn/x[m]);
      
      predY[m] = normal_rng(mu_r[m], sig_r[m]);
      log_lik[m] = normal_lpdf(predY[m]|mu_r[m], sig_r[m]);
    }
    
    return(append_col(append_col(append_col(wp, mu_r), append_col(sig_r, predY)), append_col(append_col(append_col(wp_local, wp_Dg_Pg), append_col(sig_dL_sq, sig_dG)), log_lik)));
  }
  
}

// The input data list
data {
  int<lower=0> n_mix;  //number of data points in the mix session 
  real<lower=0> X_mix[n_mix];   //stimulus duration (mix session)
  real<lower=0> Y_mix[n_mix];   //measured reproductive duration (mixed) 
  real<lower=0> xnew[162];  //new target duration for mixed group
  real mu_p_s_log;   // mean of short prior of short session in logarithmic scale
  real mu_p_l_log;   // mean of long prior of long session in logarithmic scale
  real<lower=0> sig_pr2_s_log;  // variance of short prior of short session in logarithmic scale
  real<lower=0> sig_pr2_l_log; // variance of long prior of long session in logarithmic scale
  real<lower=0, upper=4> sig2_mn;
  real<lower=0, upper=4> sig2_t; 
}

// The parameters accepted by the model. Our model
// accepts two parameters 'phi', 'mu_p_g' and 'sig2_p_g'.
parameters {
  //hyperparameters
  real<lower=-0.5, upper=0.5> phi;
  real<lower=0,upper=2.5> mu_p_g;   // mean of global prior in linear scale
  real<lower=0, upper=4> sig2_p_g;  //variance of global prior in linear scale
}


transformed parameters { 
  real mu_p_g_log;  // mean of global prior in log scale
  real<lower=0> sig2_p_g_log;  //variance of global prior in log scale
  mu_p_g_log = log(mu_p_g) - 0.5 *log(1+sig2_p_g/mu_p_g^2);
  sig2_p_g_log = log(1+sig2_p_g/mu_p_g^2);
} 

// The model to be estimated
model {
  vector[n_mix] wp_local;
  vector[n_mix] sig_dL_sq;
  vector[n_mix] mu_dL;
  vector[n_mix] wp;
  vector[n_mix] mu_r_log;
  vector[n_mix] sig_r_log;
  vector[n_mix] mu_r;
  vector[n_mix] sig_r;
  vector[n_mix] wp_Dg_Pg;
  vector[n_mix] mu_dG;
  vector[n_mix] sig_dG;
  
  //mix session
  for (m in 1:n_mix) {
    if (X_mix[m] < 1){
      //H3:short prior and integrates with the sensory input  
      wp_local[m] = get_weight(sig2_t, sig_pr2_s_log); //weight of local short prior
      mu_dL[m] = get_mu(wp_local[m], mu_p_s_log, log(X_mix[m]));
      sig_dL_sq[m] = get_variance(sig2_t, sig_pr2_s_log);
    }else{
      //H3:long prior and integrates with the sensory input  
      wp_local[m] = get_weight(sig2_t, sig_pr2_l_log);  //weight of local long prior
      mu_dL[m] = get_mu(wp_local[m], mu_p_l_log, log(X_mix[m]));
      sig_dL_sq[m] = get_variance(sig2_t, sig_pr2_l_log);
    }
    //meanwile global prior and integrates with the sensory input 
    wp_Dg_Pg[m] = get_weight(sig2_t, sig2_p_g_log);  //weight of global prior in DG
    mu_dG[m] = get_mu(wp_Dg_Pg[m],  mu_p_g_log, log(X_mix[m]));
    sig_dG[m] = get_variance(sig2_t, sig2_p_g_log);
    
    wp[m] = (sig_dL_sq[m] - phi*sqrt(sig_dG[m] *sig_dL_sq[m])) /(sig_dG[m]+sig_dL_sq[m]- 2*phi*sqrt(sig_dG[m]*sig_dL_sq[m])); //weight of D_G
    mu_r_log[m] = get_mu(wp[m], mu_dG[m], mu_dL[m]);
    sig_r_log[m] = (1-phi^2)*sig_dG[m]*sig_dL_sq[m] / (sig_dL_sq[m]+sig_dG[m]-2*phi*sqrt(sig_dG[m]*sig_dL_sq[m]));
    mu_r[m] = mu_normal(mu_r_log[m], sig_r_log[m]);
    sig_r[m] =sqrt(variance_normal(mu_r_log[m], sig_r_log[m]) +sig2_mn/X_mix[m]);
    Y_mix[m] ~ normal(mu_r[m], sig_r[m]);  
  }
}

// predicted data based on the estimated parameters
generated quantities {
  matrix[n_mix, 9] ypred_mix;
  matrix[162, 9] ynew_mix;
  vector[n_mix] log_lik;
  real log_lik_sum;
  ynew_mix = predictor_mix_rng(xnew, sig2_t, sig_pr2_s_log, sig_pr2_l_log, sig2_p_g_log, mu_p_s_log, mu_p_l_log, mu_p_g_log, sig2_mn, phi);
  ypred_mix = predictor_mix_rng(X_mix, sig2_t, sig_pr2_s_log, sig_pr2_l_log, sig2_p_g_log, mu_p_s_log, mu_p_l_log, mu_p_g_log, sig2_mn, phi);
  log_lik = col(ypred_mix, 9);
  log_lik_sum = sum(log_lik);
}