//   
// This Stan program defines a local-global model(LGM) to fit the IR condition data 
// to estimate the glboal prior.
// local-global model(LGM) assumes that the sensory input(DS) first integrates 
// with the local prior(PL) to form posterior(DL), and the formed posterior(DL) 
// further integrates with the global prior(PG) to generate reproduction (Dr)
// step1: integration of sensory input with local priors; 
// step2: posterior variances D_L; 
// step3: integration of posterior with global prior

// The user defined functions
functions {

  real get_weight(real sig_t, real sig_p){
    return(sig_t /(sig_t + sig_p));
  }
  
  real get_mu(real wp_p, real mu_p, real x){  
    return(wp_p *mu_p +(1-wp_p) * x);
  }
  
  real get_variance(real sig_t, real sig_p){
    return(sig_t*sig_p/(sig_t + sig_p));
  }
  
  matrix predictor_mix_rng(real[] x, real sig_t, real sig_pr2_s, real sig_pr2_l, real sig2_p_g, real mu_p_s, real mu_p_l, real mu_p_g, real sig2_mn) {
  vector[num_elements(x)] predY;         //predication of RP generated by model
  vector[num_elements(x)] wp_local;
  vector[num_elements(x)] mu_dL;
  vector[num_elements(x)] sig_dL_sq;
  vector[num_elements(x)] wp;
  vector[num_elements(x)] mu_r;
  vector[num_elements(x)] sig_r;
  vector[num_elements(x)] log_lik;
  
  for (m in 1:num_elements(x)) {
  ////integration of local priors firstly
  if (x[m] < 1){
    wp_local[m] = get_weight((x[m]*sig_t)^2, sig_pr2_s); //weight of local short prior
    mu_dL[m] = get_mu(wp_local[m], mu_p_s, x[m]);
    sig_dL_sq[m] = get_variance((x[m]*sig_t)^2, sig_pr2_s);
  }else{
    wp_local[m] = get_weight((x[m]*sig_t)^2, sig_pr2_l); //weight of local long prior
    mu_dL[m] = get_mu(wp_local[m], mu_p_l, x[m]);
    sig_dL_sq[m] = get_variance((x[m]*sig_t)^2, sig_pr2_l);
  }
  
  //integration of the global prior
  wp[m] = get_weight(sig_dL_sq[m], sig2_p_g);
  mu_r[m] = get_mu(wp[m], mu_p_g, mu_dL[m]);
  sig_r[m] =sqrt(get_variance(sig2_p_g, sig_dL_sq[m])+sig2_mn);
  predY[m] = normal_rng(mu_r[m], sig_r[m]); 
  log_lik[m] = normal_lpdf(predY[m]|mu_r[m], sig_r[m]);
  }
  return(append_col(append_col(append_col(wp, mu_r), append_col(sig_r, predY)), append_col(append_col(wp_local, sig_dL_sq), log_lik)));
  }
}

// The input data list
data {
  int<lower=0> n_mix;  //number of data points in the mix session 
  real<lower=0> X_mix[n_mix];   //stimulus duration (mix group)
  real<lower=0> Y_mix[n_mix];   //measured reproductive duration (mixed) 
  real<lower=0> xnew[162];  //new target duration for mixed group
  real<lower=0> mu_p_s;   // mean of short prior of short session in linear scale
  real<lower=0> mu_p_l;   // mean of long prior of long session in linear scale
  real sig_pr2_s;  // variance of short prior of short session in linear scale
  real sig_pr2_l; // variance of long prior of long session in linear scale
  real<lower=0, upper=4> sig2_mn;
  real<lower=0, upper=4> sig_t; 
}

// The parameters accepted by the model. Our model
// accepts two parameters 'mu_p_g' and 'sig2_p_g'.
parameters {
  //hyperparameters
  real<lower=0.5, upper =2.4> mu_p_g;   // mean of global prior in linear scale
  real<lower=0, upper =2> sig2_p_g;  //variance of global prior in linear scale
}

// The model to be estimated
model {
  vector[n_mix] sig_sm2;
  vector[n_mix] wp_local;
  vector[n_mix] sig_dL_sq;
  vector[n_mix] mu_dL;
  vector[n_mix] wp;
  vector[n_mix] mu_r;
  vector[n_mix] sig_r;
  
  //mixed session
  for (m in 1:n_mix) {
  //integration of local priors firstly
  if (X_mix[m] < 1){
    wp_local[m] = get_weight((X_mix[m]*sig_t)^2, sig_pr2_s); //weight of local short prior
    mu_dL[m] = get_mu(wp_local[m], mu_p_s, X_mix[m]);
    sig_dL_sq[m] = get_variance((X_mix[m]*sig_t)^2, sig_pr2_s);
  }else{
    wp_local[m] = get_weight((X_mix[m]*sig_t)^2, sig_pr2_l); //weight of local long prior
    mu_dL[m] = get_mu(wp_local[m], mu_p_l, X_mix[m]);
    sig_dL_sq[m] = get_variance((X_mix[m]*sig_t)^2, sig_pr2_l);
  }
  
  //integration of the global prior
  wp[m] = get_weight(sig_dL_sq[m], sig2_p_g);
  mu_r[m] = get_mu(wp[m], mu_p_g, mu_dL[m]);
  sig_r[m] =sqrt(get_variance(sig2_p_g, sig_dL_sq[m])+sig2_mn);
  Y_mix[m] ~ normal(mu_r[m], sig_r[m]);  
  }
}

// predicted data based on the estimated parameters
generated quantities {
  matrix[n_mix, 7] ypred_mix;
  matrix[162, 7] ynew_mix;
  vector[n_mix] log_lik;
  real log_lik_sum;
  ynew_mix = predictor_mix_rng(xnew, sig_t, sig_pr2_s, sig_pr2_l, sig2_p_g, mu_p_s, mu_p_l, mu_p_g, sig2_mn);
  ypred_mix = predictor_mix_rng(X_mix, sig_t, sig_pr2_s, sig_pr2_l, sig2_p_g, mu_p_s, mu_p_l, mu_p_g, sig2_mn);
  log_lik = col(ypred_mix, 7);
  log_lik_sum = sum(log_lik);
}