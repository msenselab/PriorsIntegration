//
// This Stan program defines a simple model, with a
// vector of values 'y' modeled as normally distributed
// with mean 'mu' and standard deviation 'sigma'.
//
// Learn more about model development with Stan at:
//
//    http://mc-stan.org/users/interfaces/rstan.html
//    https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started
//

functions {
  real get_weight(real sig_t, real sig_p){
    return(sig_t /(sig_t + sig_p));
  }
  
  real get_mu(real wp_p, real mu_p, real x){  
    return(wp_p *mu_p +(1-wp_p) * x);
  }
  
  real get_variance(real sig_t, real sig_p){
    return(sig_t*sig_p/(sig_t + sig_p));
  }
  
  matrix predictor_mix_rng(real[] x, real sig_t, real sig_pr2_s, real sig_pr2_l, real mu_p_s, real mu_p_l, real sig2_mn, real mix_p) {
    vector[num_elements(x)] predY;         //predication of RP generated by model
    vector[num_elements(x)] predY_s; 
    vector[num_elements(x)] predY_l; 
    vector[num_elements(x)] predY_Ds; 
    vector[num_elements(x)] mu_r;
    vector[num_elements(x)] log_lik;
    vector[num_elements(x)] wp_s;
    vector[num_elements(x)] wp_l;
    vector[2] mu;
    vector[2] sigma;
    int idx;
    //mixed session
    for (m in 1:num_elements(x)) {
    wp_s[m] = get_weight((x[m]*sig_t)^2, sig_pr2_s); //weight of short prior
    mu[1] = get_mu(wp_s[m], mu_p_s, x[m]);
    sigma[1] =  sqrt(get_variance((x[m]*sig_t)^2, sig_pr2_s) +sig2_mn);
    
    wp_l[m] = get_weight((x[m]*sig_t)^2, sig_pr2_l); //weight of long prior
    mu[2] = get_mu(wp_l[m], mu_p_l, x[m]);
    sigma[2] =  sqrt(get_variance((x[m]*sig_t)^2, sig_pr2_s) +sig2_mn);
    
    predY_s[m] = mix_p*mu[1];
    predY_l[m] = (1-mix_p)*mu[2];
    mu_r[m] =  predY_s[m]+ predY_l[m];
    predY[m] = mu_r[m];
    log_lik[m] = log_mix(mix_p,
    normal_lpdf(predY[m]| mu[1], sigma[1]),
    normal_lpdf(predY[m]| mu[2], sigma[2]));
    }
    
    return(append_col(append_col(append_col(append_col(predY_s, predY_l), append_col(predY, mu_r)), append_col(wp_s, wp_l)), log_lik));
  }
}

data {
  int<lower=0> n_mix;  //number of data points in the mix session 
  real<lower=0> X_mix[n_mix];   //stimulus duration (mix group)
  real<lower=0> Y_mix[n_mix];   //measured reproductive duration (mixed) 
  real<lower=0> xnew[162];  //new target duration for mixed group
  real<lower=0> mu_p_s;   // mean of short prior of short session in linear scale
  real<lower=0> mu_p_l;   // mean of long prior of long session in linear scale
  real<lower=0> sig_pr2_s;  // variance of short prior of short session in linear scale
  real<lower=0> sig_pr2_l; // variance of long prior of long session in linear scale
  real<lower=0, upper=4> sig2_mn;
  real<lower=0, upper=4> sig_t; 
  int<lower=1, upper=10> X_idx[n_mix];
}

parameters {
  //hyperparameters
  //simplex[2] mp; unit simplexes 
  real<lower=0, upper=1> mp;
}

model {
  vector[n_mix] wp;
  //matrix[2, 1] lps;
  vector[2] mu;
  vector[2] sigma;
  mu[1] = mu_p_s;
  mu[2] = mu_p_l;
  sigma[1] = sqrt(sig_pr2_s);
  sigma[2] = sqrt(sig_pr2_l);
  
  //mixed session
  for (m in 1:n_mix) {
  wp[m] = get_weight((X_mix[m]*sig_t)^2, sig_pr2_s); //weight of short prior
  mu[1] = get_mu(wp[m], mu_p_s, X_mix[m]);
  sigma[1] = sqrt(get_variance((X_mix[m]*sig_t)^2, sig_pr2_s) +sig2_mn);
  
  wp[m] = get_weight((X_mix[m]*sig_t)^2, sig_pr2_l); //weight of long prior
  mu[2] = get_mu(wp[m], mu_p_l, X_mix[m]);
  sigma[2] =  sqrt(get_variance((X_mix[m]*sig_t)^2, sig_pr2_s) +sig2_mn);
  
  //for (k in 1:2){
  //lps[k, 1] += lognormal_lpdf(Y_mix[m] | mu[k], sigma[k]);
  //}
  //target += log_sum_exp(lps);
  target += log_mix(mp,
  normal_lpdf(Y_mix[m] | mu[1], sigma[1]),
  normal_lpdf(Y_mix[m] | mu[2], sigma[2]));
  
  }
}
generated quantities {
  matrix[n_mix, 7] ypred_mix;
  matrix[162, 7] ynew_mix;
  vector[n_mix] log_lik;
  real log_lik_sum; 
  ynew_mix = predictor_mix_rng(xnew, sig_t, sig_pr2_s, sig_pr2_l, mu_p_s, mu_p_l, sig2_mn, mp);
  ypred_mix = predictor_mix_rng(X_mix, sig_t, sig_pr2_s, sig_pr2_l, mu_p_s, mu_p_l, sig2_mn, mp);
  log_lik = col(ypred_mix, 7);
  log_lik_sum = sum(log_lik);
}